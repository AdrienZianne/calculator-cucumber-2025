package calculator.parser.antlr;

import calculator.*;
import calculator.operation.*;
import calculator.operation.binary.*;
import calculator.operation.unary.Negation;
import calculator.operation.unary.UnaryOperation;
import calculator.operation.unary.trigonometry.Cosinus;
import calculator.operation.unary.trigonometry.Sinus;
import calculator.operation.unary.trigonometry.Tangent;
import org.antlr.v4.runtime.ParserRuleContext;
import org.antlr.v4.runtime.tree.TerminalNode;
import visitor.Evaluator;

import java.math.BigInteger;
import java.util.ArrayList;
import java.util.List;

/**
 * A class that maps the generated parser to the calculator custom classes.
 * This class was not generated by ANTLR, and needs to be manually modified when the grammar changes.
 */
public class ExpressionParser extends LabeledExprBaseVisitor<Expression>
{
    @Override
    public Expression visitExpr(LabeledExprParser.ExprContext ctx) {
        return visit(ctx.getChild(0));
    }

    /* _________________________________ INFIX _________________________________ */
    @Override
    public Expression visitSumInfixAdd(LabeledExprParser.SumInfixAddContext ctx) {
        return parseToBinaryOperator(ctx, expressions -> new Plus(expressions, Notation.INFIX));
    }

    @Override
    public Expression visitSumInfixDiff(LabeledExprParser.SumInfixDiffContext ctx) {
        return parseToBinaryOperator(ctx, expressions -> new Minus(expressions, Notation.INFIX));
    }

    @Override
    public Expression visitProductInfixMult(LabeledExprParser.ProductInfixMultContext ctx) {
        return parseToBinaryOperator(ctx, expressions -> new Times(expressions, Notation.INFIX));
    }

    @Override
    public Expression visitProductInfixDiv(LabeledExprParser.ProductInfixDivContext ctx) {
        return parseToBinaryOperator(ctx, expressions -> new Divides(expressions, Notation.INFIX));
    }

    @Override
    public Expression visitAtomInfixNeg(LabeledExprParser.AtomInfixNegContext ctx) {
        return parseToUnaryOperator(ctx, expressions -> new Negation(expressions, Notation.INFIX));
    }

    @Override
    public Expression visitTrigoInfixSin(LabeledExprParser.TrigoInfixSinContext ctx) {
        return parseToUnaryOperator(ctx, expression -> new Sinus(expression, Notation.INFIX));
    }

    @Override
    public Expression visitTrigoInfixCos(LabeledExprParser.TrigoInfixCosContext ctx) {
        return parseToUnaryOperator(ctx, expression -> new Cosinus(expression, Notation.INFIX));
    }

    @Override
    public Expression visitTrigoInfixTan(LabeledExprParser.TrigoInfixTanContext ctx) {
        return parseToUnaryOperator(ctx, expression -> new Tangent(expression, Notation.INFIX));
    }

    @Override
    public Expression visitAtomInfixSum(LabeledExprParser.AtomInfixSumContext ctx) {
        // We only need to visit the second child, since the first and third ones are parentheses.
        return ctx.getChild(1).accept(this);
    }

    /* _________________________________ PREFIX _________________________________ */

    @Override
    public Expression visitSumPrefixSum(LabeledExprParser.SumPrefixSumContext ctx) {
        return parseToBinaryOperator(ctx, expressions -> new Plus(expressions, Notation.PREFIX));
    }

    @Override
    public Expression visitSumPrefixDiff(LabeledExprParser.SumPrefixDiffContext ctx) {
        return parseToBinaryOperator(ctx, expressions -> new Minus(expressions, Notation.PREFIX));
    }

    @Override
    public Expression visitProductPrefixMult(LabeledExprParser.ProductPrefixMultContext ctx) {
        return parseToBinaryOperator(ctx, expressions -> new Times(expressions, Notation.PREFIX));
    }

    @Override
    public Expression visitProductPrefixDiv(LabeledExprParser.ProductPrefixDivContext ctx) {
        return parseToBinaryOperator(ctx, expressions -> new Divides(expressions, Notation.PREFIX));
    }
    /* _________________________________ POSTFIX _________________________________ */

    @Override
    public Expression visitSumPostfixSum(LabeledExprParser.SumPostfixSumContext ctx) {
        return parseToBinaryOperator(ctx, expressions -> new Plus(expressions, Notation.POSTFIX));
    }

    @Override
    public Expression visitSumPostfixDiff(LabeledExprParser.SumPostfixDiffContext ctx) {
        return parseToBinaryOperator(ctx, expressions -> new Minus(expressions, Notation.POSTFIX));
    }

    @Override
    public Expression visitProductPostfixMult(LabeledExprParser.ProductPostfixMultContext ctx) {
        return parseToBinaryOperator(ctx, expressions -> new Times(expressions, Notation.POSTFIX));
    }

    @Override
    public Expression visitProductPostfixDiv(LabeledExprParser.ProductPostfixDivContext ctx) {
        return parseToBinaryOperator(ctx, expressions -> new Divides(expressions, Notation.POSTFIX));
    }

    /* __________________________________ NUMBER _______________________________ */

    @Override
    public Expression visitNumberInt(LabeledExprParser.NumberIntContext ctx) {
        return new MyInteger(new BigInteger(ctx.INT().getText()));
    }

    @Override
    public Expression visitNumberReal(LabeledExprParser.NumberRealContext ctx) {
        return new MyReal(ctx.FLOAT().getText());
    }

    @Override
    public Expression visitRational(LabeledExprParser.RationalContext ctx) {
        // We suppose that the rational has 3 child : the numerator, the operator `/` and the denominator
        return new MyRational(Integer.parseInt(ctx.getChild(0).getText()), Integer.parseInt(ctx.getChild(2).getText())).simplify();
    }

    @Override
    public Expression visitComplexImaginaryNumber(LabeledExprParser.ComplexImaginaryNumberContext ctx) {
        if (ctx.getChildCount() == 1) {return new MyComplex(new MyInteger(0), new MyInteger(1));}

        return new MyComplex(new MyInteger(0), (MyNumber) visit(ctx.getChild(0)));
    }

    @Override
    public Expression visitNumberNegation(LabeledExprParser.NumberNegationContext ctx) {
        // We are using infix as that is a special operation, this is simply applying a negation to an atomic value
        return parseToUnaryOperator(ctx, expressions -> new Negation(expressions, Notation.INFIX));
    }

    //__________________________________Static Functions__________________________


    /**
     * Parses the given context as expressions and feeds them to a binary operation.
     * @param ctx       The context to parse
     * @param operation The binary operation to build and to give the parsed expressions as parameters.
     * @return The created operation
     * @param <E>   The current parser rule context
     * @param <O>   The type of operation to build
     */
    public <E extends ParserRuleContext, O extends BinaryOperation> O parseToBinaryOperator(E ctx, BuildOperationFunction<O> operation) {
        ArrayList<Expression> expressions = new ArrayList<>();
        Evaluator v;
        for (int i = 0; i < ctx.getChildCount(); i++) {
            // Checks if the node is a token without any interesting values
            if (! (ctx.getChild(i) instanceof TerminalNode)) {
                v = new Evaluator();
                try {
                    visit(ctx.getChild(i)).accept(v);
                }
                catch (Exception e) {throw new RuntimeException(e);} // FIXME : Adrien Fievet should have a look at that
                expressions.add(v.getResult());
            }
        }
        O res = null;
        try {
            res = operation.build(expressions);
        } catch (IllegalConstruction e) {
            throw new RuntimeException(e);
        }
        return res;
    }

    /**
     * Parses the given context as expressions and feeds them to a unary operation.
     * @param ctx       The context to parse.
     *                  This function assumes that the exploration can stop after finding a branch that returned an expression as
     *                  a unary operator always as one argument.
     * @param operation The unary operation to build and to give the parsed expression as a parameter
     *                  (under the form of an {@link ArrayList} composed of only one element).
     * @return The created operation
     * @param <E>   The current parser rule context
     * @param <O>   The type of operation to build
     */
    public <E extends ParserRuleContext, O extends UnaryOperation> O parseToUnaryOperator(E ctx, BuildUnaryOperationFunction<O> operation) {
        Expression expression = null;
        Evaluator v;
        // Explore all path to find the argument to pass to the unary operator.
        for (int i = 0; i < ctx.getChildCount(); i++) {
            // Checks if the node is a token without any interesting values
            if (! (ctx.getChild(i) instanceof TerminalNode)) {
                v = new Evaluator();
                try {
                    visit(ctx.getChild(i)).accept(v);
                }
                catch (Exception e) {throw new RuntimeException(e);} // FIXME : Adrien Fievet should have a look at that
                // We can stop after finding the only expression as this is a unary operation
                expression = v.getResult();
                break;
            }
        }
        O res = null;
        try {
            if (expression == null) {
                throw new IllegalConstruction();
            }
            res = operation.build(expression);
        } catch (IllegalConstruction e) {
            throw new RuntimeException(e);
        }
        return res;
    }


}
