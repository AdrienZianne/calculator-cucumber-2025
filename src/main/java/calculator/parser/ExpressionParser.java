package calculator.parser;

import calculator.*;
import org.antlr.v4.runtime.ParserRuleContext;

import java.util.ArrayList;
import java.util.List;

/**
 * A class that maps the generated parser to the calculator custom classes.
 * This class was not generated by ANTLR, and needs to be manually modified when the grammar changes.
 */
public class ExpressionParser extends LabeledExprBaseVisitor<Expression>
{
    @Override
    public Expression visitExprInfix(LabeledExprParser.ExprInfixContext ctx) {
        return ctx.getChild(0).accept(this);
    }


    @Override
    public Expression visitSumInfixAdd(LabeledExprParser.SumInfixAddContext ctx) {
        return setFactors(ctx, this, () -> new Plus(new ArrayList<>(), Notation.INFIX));
    }

    @Override
    public Expression visitSumInfixDiff(LabeledExprParser.SumInfixDiffContext ctx) {
        return setFactors(ctx, this, () -> new Minus(new ArrayList<>(), Notation.INFIX));
    }

    @Override
    public Expression visitProductInfixMult(LabeledExprParser.ProductInfixMultContext ctx) {
        return setFactors(ctx, this, () -> new Times(new ArrayList<>(), Notation.INFIX));
    }

    @Override
    public Expression visitProductInfixDiv(LabeledExprParser.ProductInfixDivContext ctx) {
        return setFactors(ctx, this, () -> new Divides(new ArrayList<>(), Notation.INFIX));
    }


    @Override
    public Expression visitAtomInfixSum(LabeledExprParser.AtomInfixSumContext ctx) {
        // We only need to visit the second child, since the first and third ones are parentheses.
        return ctx.getChild(1).accept(this);
    }

    @Override
    public Expression visitAtomInfixInt(LabeledExprParser.AtomInfixIntContext ctx) {
        // We are at the end of the parse tree, we can simply parse the text as an int
        return new MyNumber(Integer.parseInt(ctx.getText()));
    }

    //__________________________________Static Functions__________________________

    /**
     * Sets the factor of a given operator by visiting the child nodes
     * @param ctx   The parser context
     * @param visitor   The visitor
     * @param operation The operation
     */
    private static <E extends ParserRuleContext, O extends Operation> O setFactors(E ctx, LabeledExprBaseVisitor<Expression> visitor, BuildOperationFunction<O> operation)
    {
        // We evaluate both factors (but not the second child since it is the operator character)
        Expression factor1 = ctx.getChild(0).accept(visitor);
        Expression factor2 = ctx.getChild(2).accept(visitor);
        // Add the factors to the given operation
        O res = null;
        try {
            res = operation.build();
        } catch (IllegalConstruction e) {
            throw new RuntimeException(e);
        }
        res.addMoreParams(List.of(factor1, factor2));
        return res;
    }

}
